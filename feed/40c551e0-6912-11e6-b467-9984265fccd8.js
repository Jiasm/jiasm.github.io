{
  "id": "40c551e0-6912-11e6-b467-9984265fccd8",
  "title": "co源码解读",
  "postDate": "2016/08/23 17:16",
  "content": "<h2>背景：</h2>\r\n<p>&nbsp; &nbsp; 闲来无事，翻了下co的源码来看，源码短小精悍，算上注释，一共240行左右；</p>\r\n<p>&nbsp; &nbsp; 决定写一篇博客来记录下学习的心得。</p>\r\n<p>&nbsp; &nbsp; TJ大神的co：<a href=\"https://github.com/tj/co\">https://github.com/tj/co</a></p>\r\n<p>&nbsp;</p>\r\n<h2>作用：</h2>\r\n<p>&nbsp; &nbsp; co通过将<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\">Generator函数</a>拆成一个<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise</a>将码农从<a href=\"http://callbackhell.com/\">callback hell</a>中拯救了出来；</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp; &nbsp; 下边放出一段代码，对比下co与普通回调版本的区别：</p>\r\n<pre class=\"language-javascript line-numbers\"><code>/**\r\n *  回调版本\r\n */\r\n\r\nlet fs = require('fs')\r\n\r\nfs.readFile('./package.json', (err, data) =&gt; {\r\n  if (err) {\r\n    return console.log(err)\r\n  }\r\n  console.log(data.toString())\r\n  fs.readFile('./package.json', (err, data) =&gt; {\r\n    if (err) {\r\n      return console.log(err)\r\n    }\r\n    console.log(data.toString())\r\n  })\r\n})\r\n\r\n/**\r\n *  co版本\r\n */\r\n\r\nlet co = require('co')\r\nlet fs = require('fs')\r\n\r\nco(function * () {\r\n  let a = yield fs.readFile.bind(null, './package.json')\r\n  console.log(a.toString())\r\n  let b = yield fs.readFile.bind(null, './package.json')\r\n  console.log(b.toString())\r\n}).then(console.log, console.error)</code></pre>\r\n<p>从代码上看，貌似co是一个同步执行的过程呢。当然，也只是看起来像而已。</p>\r\n<p>&nbsp;</p>\r\n<h2>正题：</h2>\r\n<p>&nbsp; &nbsp; 先来说一下co整个执行的过程：</p>\r\n<ul>\r\n<li>调用co，传入一个Generator函数，函数会返回一个Promise对象</li>\r\n<li>如果传入参数为Generator函数，会执行该函数来进行Generator的初始化</li>\r\n<li>手动执行一次next() 这时Generator函数就会停在第一次遇到yield关键字的地方</li>\r\n<li>获取到yield后边的值，将其转换为一个Promise函数，然后执行之</li>\r\n<li>重复上边两步，直到函数执行完毕</li>\r\n</ul>\r\n<p>&nbsp; &nbsp; co关于yield后边的值也是有一定的要求的，只能是一个 Function｜Promise｜Generator ｜ Array | Object；</p>\r\n<p>&nbsp; &nbsp; 而 Array和Object中的item也必须是 Function｜Promise｜Generator。</p>\r\n<p>&nbsp; &nbsp; 并且关于function 普通函数并不一定会得到预期的结果，co需要的是 接收一个回调函数 并执行的函数，类似于这样：</p>\r\n<pre class=\"language-javascript line-numbers\"><code>function doSomething (callback) {\r\n  callback(null, 'hello')\r\n}\r\nco(function * () {\r\n  let result = yield doSomething\r\n  console.log(result)  // =&gt; hello\r\n})</code></pre>\r\n<p>&nbsp; &nbsp; 总而言之，co执行的肯定是一个Promise，而co会帮你把其他几种类型的值转换为Promise，co绝大部份的代码都是在处理类型的转换；</p>\r\n<p>&nbsp; &nbsp; 当然，在讲类型转换的那一块之前，还是将co执行Generator的那几个函数说一下子，也就是调用co返回的Promise中的那三个函数（onFulfilled、onRejected、next）；</p>\r\n<p>&nbsp; &nbsp; 因next与Generator对象的next方法名相同 这里使用 gen.next 表示 Generator对象的next方法。</p>\r\n<p>&nbsp;</p>\r\n<h3>onFulfilled：</h3>\r\n<p>&nbsp; &nbsp; 调用gen.next并将上次执行的结果传入gen.next；</p>\r\n<p>&nbsp; &nbsp; 调用next，将gen.next返回的值传入next。</p>\r\n<p>&nbsp;</p>\r\n<h3>onRejected：</h3>\r\n<p>&nbsp; &nbsp; 执行流程与 onFulfilled 一致，只不过是将调用的 gen.next 换为了 gen.throw 用来将错误异常抛出。</p>\r\n<p>&nbsp;</p>\r\n<h3>next：</h3>\r\n<p>&nbsp; &nbsp; 函数会判断传入参数的done属性，如果为true（ 则表示该Generator已经执行完毕），会调用co返回的Promise对象的resolve方法，结束代码执行；</p>\r\n<p>&nbsp; &nbsp; 如果done为false 则表示还需要继续执行，这里会将 yield后边的值（参数的value属性）转换为Promise，并调用then方法传入 onFulfilled 和 onRejected两个函数。</p>\r\n<p>&nbsp; &nbsp; co整个的执行流程其实就是这样的-.-&nbsp;</p>\r\n<p>&nbsp; &nbsp; 剩余代码所完成的事情就是将各种不同的类型转换为可执行的Promise对象。</p>\r\n<p>&nbsp;</p>\r\n<h3>thunkToPromise（Function）：</h3>\r\n<p>&nbsp; &nbsp; 函数返回一个Promise对象，在Promise内部执行了传入的function；</p>\r\n<p>&nbsp; &nbsp; 并会认为回调的第一个参数为Error（这个貌似是个标准...）；</p>\r\n<p>&nbsp; &nbsp; 将其余参数打包到一个数组中返回。</p>\r\n<p>&nbsp;</p>\r\n<h3>arrayToPromise（Array）：</h3>\r\n<p>&nbsp; &nbsp; Promise有一个方法叫做all，会返回数组中所有Promise执行后的返回值（如果有其中一项被reject掉，所有的都会被reject）；</p>\r\n<p>&nbsp; &nbsp; 方法会返回&nbsp;<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\">Promise.all()</a>&nbsp;的执行结果</p>\r\n<pre class=\"language-javascript line-numbers\"><code>Promise.all([\r\n  Promise.resolve('hello'),\r\n  Promise.resolve('world')\r\n]).then(data =&gt; {\r\n  console.log(data)  // =&gt; ['hello', 'world']\r\n})</code></pre>\r\n<p>&nbsp;</p>\r\n<h3>objectToPromise（Object）：</h3>\r\n<p>&nbsp; &nbsp; 函数用来将一个Object对象转换为Promise；</p>\r\n<p>&nbsp; &nbsp; 应该是co源码中行数最多的一个函数了😜 &nbsp;具体做的事儿呢；</p>\r\n<p>&nbsp; &nbsp; 就是将一个Object的每一个key都转换为Promise，并塞到一个数组中；</p>\r\n<p>&nbsp; &nbsp; 执行Promise.all()将上边的数组塞进去；</p>\r\n<p>&nbsp; &nbsp; 当某一个key所对应的Promise函数执行完毕后，会将执行的结果塞回对应的key中；</p>\r\n<p>&nbsp; &nbsp; 全部执行完毕后，就会返回该Object。</p>\r\n<pre class=\"language-javascript line-numbers\"><code>{\r\n  a: Promise.resolve('hello'),\r\n  b: Promise.resolve('world')\r\n}\r\n\r\n// =&gt;\r\n\r\n{\r\n  a: 'hello',\r\n  b: 'world'\r\n}</code></pre>\r\n<p>&nbsp;</p>\r\n<p>其余的几个函数就是判断类型了， isPromise、isGenerator、isGeneratorFunction、isObject。</p>\r\n<p>&nbsp;</p>\r\n<h2>小记：</h2>\r\n<p>因我司在用koa来搭建web项目，所以会接触到这些东西，就想写点博客记录一下；</p>\r\n<p>本人文笔简直负分，望各位海涵，如有什么不懂的，欢迎邮件骚扰。</p>\r\n<p><a href=\"mailto:jiashunming@outlook.com\">jiashunming@outlook.com</a>&nbsp;</p>\r\n<p>文章相关代码会在GitHub更新：</p>\r\n<p><a href=\"https://github.com/Jiasm/blog-resource/tree/master/co\">https://github.com/Jiasm/blog-resource/tree/master/co</a>&nbsp;</p>"
}

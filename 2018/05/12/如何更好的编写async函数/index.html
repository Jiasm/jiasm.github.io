<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  
  
  
  <title>如何更好的编写async函数 - Jarvis&#39;s Blog</title>
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/prism-coy.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head>


  <body class="fixed">
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">Jarvis&#39;s Blog</a>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link menu-item-home">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link menu-item-about">About</a>
        </li>
      
        <li class="menu-item">
          <a href="/contact" class="menu-item-link menu-item-contact">Contact</a>
        </li>
      
        <li class="menu-item">
          <a href="/links" class="menu-item-link menu-item-friends">Friends</a>
        </li>
      
        <li class="menu-item">
          <a href="https://github.com/jiasm" class="menu-item-link menu-item-github">Github</a>
        </li>
      
    </ul>
  </nav>
</header>

        <main class="main">
          
  <input type="checkbox" id="toggle-toc" class="toggle-toc-right" />
  <div class="toc-toggle toc-toggle-right">
    <label for="toggle-toc">
      <i class="fa fa-list-ol"></i>
    </label>
    <div class="toc-wrap toc-wrap-right">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#首先，你需要了解Promise"><span class="toc-number">1.</span> <span class="toc-text">首先，你需要了解Promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async与Promise的关系"><span class="toc-number">2.</span> <span class="toc-text">async与Promise的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async函数代码执行是同步的，结果返回是异步的"><span class="toc-number">3.</span> <span class="toc-text">async函数代码执行是同步的，结果返回是异步的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise内部的Promise会被消化"><span class="toc-number">4.</span> <span class="toc-text">Promise内部的Promise会被消化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一定不要忘了await关键字"><span class="toc-number">5.</span> <span class="toc-text">一定不要忘了await关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不是所有的地方都需要添加await"><span class="toc-number">6.</span> <span class="toc-text">不是所有的地方都需要添加await</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#合并多个不相干的async函数调用"><span class="toc-number">7.</span> <span class="toc-text">合并多个不相干的async函数调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一些循环中的注意事项"><span class="toc-number">8.</span> <span class="toc-text">一些循环中的注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach"><span class="toc-number">8.1.</span> <span class="toc-text">forEach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要在普通的for、while循环中使用await"><span class="toc-number">8.2.</span> <span class="toc-text">不要在普通的for、while循环中使用await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于这两种问题的解决方案："><span class="toc-number">8.3.</span> <span class="toc-text">关于这两种问题的解决方案：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#P-S-草案中有一个await-，可以省去Promise-all"><span class="toc-number">8.3.1.</span> <span class="toc-text">P.S. 草案中有一个await*，可以省去Promise.all</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P-S-为什么在使用Generator-co时没有这个问题"><span class="toc-number">8.3.2.</span> <span class="toc-text">P.S. 为什么在使用Generator+co时没有这个问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">9.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">10.</span> <span class="toc-text">参考资料</span></a></li></ol>
    </div>
  </div>
  <label class="mask" for="toggle-toc"></label>

<div id="post-content">
  <h1>如何更好的编写async函数</h1>
  <blockquote>
<p>2018年已经到了5月份，<code>node</code>的<code>4.x</code>版本也已经停止了维护<br>我司的某个服务也已经切到了<code>8.x</code>，目前正在做<code>koa2.x</code>的迁移<br>将之前的<code>generator</code>全部替换为<code>async</code><br>但是，在替换的过程中，发现一些滥用<code>async</code>导致的时间上的浪费<br>所以来谈一下，如何优化<code>async</code>代码，更充分的利用异步事件流 <strong>杜绝滥用async</strong></p>
</blockquote>
<a id="more"></a>
<h2 id="首先，你需要了解Promise"><a href="#首先，你需要了解Promise" class="headerlink" title="首先，你需要了解Promise"></a>首先，你需要了解Promise</h2><p><code>Promise</code>是使用<code>async</code>/<code>await</code>的基础，所以你一定要先了解<code>Promise</code>是做什么的<br><code>Promise</code>是帮助解决回调地狱的一个好东西，能够让异步流程变得更清晰。<br>一个简单的<code>Error-first-callback</code>转换为<code>Promise</code>的例子：  </p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> readFile <span class="token punctuation">(</span>fileName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>fileName<span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>

      <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'test.log'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'get data'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们调用函数返回一个<code>Promise</code>的实例，在实例化的过程中进行文件的读取，当文件读取的回调触发式，进行<code>Promise</code>状态的变更，<code>resolved</code>或者<code>rejected</code><br>状态的变更我们使用<code>then</code>来监听，第一个回调为<code>resolve</code>的处理，第二个回调为<code>reject</code>的处理。</p>
<h2 id="async与Promise的关系"><a href="#async与Promise的关系" class="headerlink" title="async与Promise的关系"></a>async与Promise的关系</h2><p><code>async</code>函数相当于一个简写的返回<code>Promise</code>实例的函数，效果如下：</p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> getNumber <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// =></span>
<span class="token keyword">async</span> <span class="token keyword">function</span> getNumber <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>两者在使用上方式上完全一样，都可以在调用<code>getNumber</code>函数后使用<code>then</code>进行监听返回值。<br>以及与<code>async</code>对应的<code>await</code>语法的使用方式：  </p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token function">getNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// got data</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// =></span>
<span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>await</code>的执行会获取表达式后边的<code>Promise</code>执行结果，相当于我们调用<code>then</code>获取回调结果一样。<br><em>P.S. 在<code>async</code>/<code>await</code>支持度还不是很高的时候，大家都会选择使用<code>generator</code>/<code>yield</code>结合着一些类似于<code>co</code>的库来实现类似的效果</em></p>
<h2 id="async函数代码执行是同步的，结果返回是异步的"><a href="#async函数代码执行是同步的，结果返回是异步的" class="headerlink" title="async函数代码执行是同步的，结果返回是异步的"></a>async函数代码执行是同步的，结果返回是异步的</h2><p><code>async</code>函数总是会返回一个<code>Promise</code>的实例 <strong>这点儿很重要</strong><br>所以说调用一个<code>async</code>函数时，可以理解为里边的代码都是处于<code>new Promise</code>中，所以是同步执行的<br>而最后<code>return</code>的操作，则相当于在<code>Promise</code>中调用<code>resolve</code>：  </p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> getNumber <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'call getNumber()'</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

<span class="token function">getNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>_ <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'resolved'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'done'</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// 输出顺序：</span>
<span class="token comment" spellcheck="true">// call getNumber()</span>
<span class="token comment" spellcheck="true">// done</span>
<span class="token comment" spellcheck="true">// resolved</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Promise内部的Promise会被消化"><a href="#Promise内部的Promise会被消化" class="headerlink" title="Promise内部的Promise会被消化"></a>Promise内部的Promise会被消化</h2><p>也就是说，如果我们有如下的代码：  </p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> getNumber <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">getNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果按照上边说的话，我们在<code>then</code>里边获取到的<code>data</code>应该是传入<code>resolve</code>中的值  ，也就是另一个<code>Promise</code>的实例。<br>但实际上，我们会直接获得返回值：<code>1</code>，也就是说，如果在<code>Promise</code>中返回一个<code>Promise</code>，实际上程序会帮我们执行这个<code>Promise</code>，并在内部的<code>Promise</code>状态改变时触发<code>then</code>之类的回调。<br>一个有意思的事情：   </p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> getNumber <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Test'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">getNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Error: Test</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果我们在<code>resolve</code>中传入了一个<code>reject</code>，则我们在外部则可以直接使用<code>catch</code>监听到。<br><strong>这种方式经常用于在<code>async</code>函数中抛出异常</strong><br>如何在<code>async</code>函数中抛出异常：  </p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> getNumber <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Test'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> number <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="一定不要忘了await关键字"><a href="#一定不要忘了await关键字" class="headerlink" title="一定不要忘了await关键字"></a>一定不要忘了await关键字</h2><p>如果忘记添加<code>await</code>关键字，代码层面并不会报错，但是我们接收到的返回值却是一个<code>Promise</code>  </p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">let</span> number <span class="token operator">=</span> <span class="token function">getNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Promise</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>所以在使用时一定要切记<code>await</code>关键字  </p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">let</span> number <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="不是所有的地方都需要添加await"><a href="#不是所有的地方都需要添加await" class="headerlink" title="不是所有的地方都需要添加await"></a>不是所有的地方都需要添加await</h2><p>在代码的执行过程中，有时候，并不是所有的异步都要添加<code>await</code>的。<br>比如下边的对文件的操作：<br><em>我们假设<code>fs</code>所有的API都被我们转换为了<code>Promise</code>版本</em>  </p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> writeFile <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> fd <span class="token operator">=</span> <span class="token keyword">await</span> fs<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'test.log'</span><span class="token punctuation">)</span>
  fs<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">)</span>
  fs<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token string">'world'</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> fs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>就像上边说的，Promise内部的Promise会被消化，所以我们在最后的<code>close</code>也没有使用<code>await</code></em><br>我们通过<code>await</code>打开一个文件，然后进行两次文件的写入。<br>但是注意了，在两次文件的写入操作前边，我们并没有添加<code>await</code>关键字。<br>因为这是多余的，我们只需要通知API，我要往这个文件里边写入一行文本，顺序自然会由<code>fs</code>来控制 。<br>最后再进行<code>close</code>，因为如果我们上边在执行写入的过程还没有完成时，<code>close</code>的回调是不会触发的，<br>也就是说，回调的触发就意味着上边两步的<code>write</code>已经执行完成了。</p>
<h2 id="合并多个不相干的async函数调用"><a href="#合并多个不相干的async函数调用" class="headerlink" title="合并多个不相干的async函数调用"></a>合并多个不相干的async函数调用</h2><p>如果我们现在要获取一个用户的头像和用户的详细信息（而这是两个接口 <em>虽说一般情况下不太会出现</em>）   </p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> getUser <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> avatar <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getAvatar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> userInfo <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getUserInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    avatar<span class="token punctuation">,</span>
    userInfo
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样的代码就造成了一个问题，我们获取用户信息的接口并不依赖于头像接口的返回值。<br>但是这样的代码却会在获取到头像以后才会去发送获取用户信息的请求。<br>所以我们对这种代码可以这样处理：  </p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> getUser <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">[</span>avatar<span class="token punctuation">,</span> userInfo<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">getAvatar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getUserInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    avatar<span class="token punctuation">,</span>
    userInfo
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样的修改就会让<code>getAvatar</code>与<code>getUserInfo</code>内部的代码同时执行，同时发送两个请求，在外层通过包一层<code>Promise.all</code>来确保两者都返回结果。  </p>
<p><strong>让相互没有依赖关系的异步函数同时执行</strong></p>
<h2 id="一些循环中的注意事项"><a href="#一些循环中的注意事项" class="headerlink" title="一些循环中的注意事项"></a>一些循环中的注意事项</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>当我们调用这样的代码时：  </p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> getUsersInfo <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">async</span> uid <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">await</span> <span class="token function">getUserInfo</span><span class="token punctuation">(</span>uid<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> getuserInfo <span class="token punctuation">(</span>uid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>_ <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span>uid<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">await</span> <span class="token function">getUsersInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样的执行好像并没有什么问题，我们也会得到<code>1</code>、<code>2</code>、<code>3</code>三条<code>log</code>的输出，<br>但是当我们在<code>await getUsersInfo()</code>下边再添加一条<code>console.log(&#39;done&#39;)</code>的话，就会发现：<br>我们会先得到<code>done</code>，然后才是三条<code>uid</code>的<code>log</code>，也就是说，<code>getUsersInfo</code>返回结果时，其实内部<code>Promise</code>并没有执行完。<br>这是因为<code>forEach</code>并不会关心回调函数的返回值是什么，它只是运行回调。  </p>
<h3 id="不要在普通的for、while循环中使用await"><a href="#不要在普通的for、while循环中使用await" class="headerlink" title="不要在普通的for、while循环中使用await"></a>不要在普通的for、while循环中使用await</h3><p>使用普通的<code>for</code>、<code>while</code>循环会导致程序变为串行：  </p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> uid <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getUserInfo</span><span class="token punctuation">(</span>uid<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这样的代码运行，会在拿到<code>uid: 1</code>的数据后才会去请求<code>uid: 2</code>的数据  </p>
<hr>
<h3 id="关于这两种问题的解决方案："><a href="#关于这两种问题的解决方案：" class="headerlink" title="关于这两种问题的解决方案："></a>关于这两种问题的解决方案：</h3><p>目前最优的就是将其替换为<code>map</code>结合着<code>Promise.all</code>来实现：  </p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">async</span> uid <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">await</span> <span class="token function">getUserInfo</span><span class="token punctuation">(</span>uid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样的代码实现会同时实例化三个<code>Promise</code>，并请求<code>getUserInfo</code></p>
<h4 id="P-S-草案中有一个await-，可以省去Promise-all"><a href="#P-S-草案中有一个await-，可以省去Promise-all" class="headerlink" title="P.S. 草案中有一个await*，可以省去Promise.all"></a>P.S. 草案中有一个<code>await*</code>，可以省去<code>Promise.all</code></h4><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">await</span><span class="token operator">*</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">async</span> uid <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">await</span> <span class="token function">getUserInfo</span><span class="token punctuation">(</span>uid<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="P-S-为什么在使用Generator-co时没有这个问题"><a href="#P-S-为什么在使用Generator-co时没有这个问题" class="headerlink" title="P.S. 为什么在使用Generator+co时没有这个问题"></a>P.S. 为什么在使用<code>Generator</code>+<code>co</code>时没有这个问题</h4><p>在使用<code>koa1.x</code>的时候，我们直接写<code>yield [].map</code>是不会出现上述所说的串行问题的<br>看过<code>co</code>源码的小伙伴应该都明白，里边有这么两个函数（删除了其余不相关的代码）：  </p>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">toPromise</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> arrayToPromise<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">arrayToPromise</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>toPromise<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>co</code>是帮助我们添加了<code>Promise.all</code>的处理的（膜拜TJ大佬）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下关于<code>async</code>函数编写的几个小提示：</p>
<ol>
<li>使用<code>return Promise.reject()</code>在<code>async</code>函数中抛出异常</li>
<li>让相互之间没有依赖关系的异步函数同时执行</li>
<li>不要在循环的回调中/<code>for</code>、<code>while</code>循环中使用<code>await</code>，用<code>map</code>来代替它</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://2ality.com/2016/10/async-function-tips.html" target="_blank" rel="noopener">async-function-tips</a></li>
</ol>

</div>

<section class="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
<script>
  var disqus_shortname = 'jiashunming';
  
  var disqus_url = 'http://jiasm.github.io/2018/05/12/如何更好的编写async函数/';
  
  var disqus_config = function () {
    this.page.url = location.href
    this.page.identifier = '22d10490-55e7-11e8-90e5-d32659be4ecf'
    this.page.title = document.querySelector('h1').innerText
  };
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.setAttribute('data-timestamp', +new Date());
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

<script>
  // I'm not sure your browser supports `es6`
  window.addEventListener('load', function () {
    [].concat(Array.from(document.querySelectorAll('code')), Array.from(document.querySelectorAll('pre'))).filter(function (item) {return item.className.indexOf('language') >= 0}).forEach(function (tag) { tag.classList.add('line-numbers') })
    Prism.highlightAll()

    let scrollY = window.scrollY
    let headersList = Array.from(document.querySelector('#post-content').querySelectorAll('h1,h2,h3,h4,h5,h6')).map(function (item) {
      let rect = item.getBoundingClientRect()
      let anchorTag = document.querySelector(`a.toc-link[href="#${item.id}"]`)

      if (!anchorTag) return
      return {
        top: scrollY + rect.top - rect.height,
        tag: item,
        anchorTag: anchorTag
      }
    }).filter(function (item) { return item })

    window.addEventListener('scroll', debounce(scrollHandler, 200))
    scrollHandler()

    function scrollHandler () {
      let scrollY = window.scrollY
      let minInfo = null

      for (let item of headersList) {
        if (!minInfo) {
          minInfo = item
          continue
        }

        if ((scrollY - item.top) >= 0 && (scrollY - minInfo.top) > (scrollY - item.top)) {
          minInfo = item
        }
      }

      if (minInfo) {
        headersList.forEach(function (item) {
          item.anchorTag && item.anchorTag.classList.remove('selected')
        })
        minInfo.anchorTag.classList.add('selected')
      }
    }

    function debounce (func, delay) {
      let debounceIdentify = 0
      return function () {
        debounceIdentify && clearTimeout(debounceIdentify)
        debounceIdentify = setTimeout(function () {
          debounceIdentify = 0
          func.apply(this, arguments)
        }, delay)
      }
    }
  })
</script>

        </main>
        <a href="#" class="goto-top">
          <i class="fa fa-chevron-up"></i>
        </a>
    </div>
    <footer class="footer">
  <div class="footer-content">
    <div class="footer-info" class="inner">
      <p class="copyright">&copy; 2023 ShunMing Jia<br></p>
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      theme by <a href="https://github.com/Jiasm/hexo-theme-sheet" target="_blank">Sheet</a>
    </div>
    <ul class="contact-info">
      
        <a class="contact-link" href="https://github.com/jiasm" target="_blank"><i class="fa fa-github"></i></a>
      
      
        <a class="contact-link" href="https://weibo.com/jarvis1996" target="_blank"><i class="fa fa-weibo"></i></a>
      
      
        <a class="contact-link" href="https://twitter.com/jiashm" target="_blank"><i class="fa fa-twitter"></i></a>
      
      
        <a class="contact-link" href="https://www.facebook.com/jiashunming" target="_blank"><i class="fa fa-facebook"></i></a>
      
      
        <a class="contact-link" href="mailto:jiashunming@outlook.com" target="_blank"><i class="fa fa-envelope"></i></a>
      
    </ul>
  </div>
</footer>

  <!-- 使用 DISQUS js 代码 -->
  <script id="dsq-count-scr" src="//jiashunming.disqus.com/count.js" async="async"></script>



      <script>
      function footerHandler () {
        if (!window.screen || !document.body) return
        var hasComments = document.querySelector('.comments')
        if ((window.screen.availHeight - (hasComments ? 350 : 0)) > document.body.clientHeight) {
          document.body.classList.add('fixed')
        } else {
          document.body.classList.remove('fixed')
        }
      }
      footerHandler()
      window.addEventListener('resize', footerHandler)
    </script>
  </body>
  <script>
    var pathname = new URL(location.href).pathname.replace(/\/$/, '')

    switch (pathname) {
      case '/about':
        document.querySelector('.menu-item-about').classList.add('active')
        break
      case '/contact':
        document.querySelector('.menu-item-contact').classList.add('active')
        break
      case '/links':
        document.querySelector('.menu-item-friends').classList.add('active')
        break
      default:
        document.querySelector('.menu-item-home').classList.add('active')
    }
  </script>
  
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f1f7cb8bfb6de7f6a6277fee35703d98";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    

</html>
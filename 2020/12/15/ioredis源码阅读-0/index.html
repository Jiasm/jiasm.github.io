<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  
  
  
  <title>ioredis源码阅读[0] - Jarvis&#39;s Blog</title>
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="stylesheet" href="/css/prism-coy.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head>


  <body class="fixed">
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">Jarvis&#39;s Blog</a>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link menu-item-home">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link menu-item-about">About</a>
        </li>
      
        <li class="menu-item">
          <a href="/contact" class="menu-item-link menu-item-contact">Contact</a>
        </li>
      
        <li class="menu-item">
          <a href="/links" class="menu-item-link menu-item-friends">Friends</a>
        </li>
      
        <li class="menu-item">
          <a href="https://github.com/jiasm" class="menu-item-link menu-item-github">Github</a>
        </li>
      
    </ul>
  </nav>
</header>

        <main class="main">
          
  <input type="checkbox" id="toggle-toc" class="toggle-toc-right" />
  <div class="toc-toggle toc-toggle-right">
    <label for="toggle-toc">
      <i class="fa fa-list-ol"></i>
    </label>
    <div class="toc-wrap toc-wrap-right">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ioredis-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">ioredis 项目结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">Redis 实例化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Commander"><span class="toc-number">3.</span> <span class="toc-text">Commander</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Command"><span class="toc-number">4.</span> <span class="toc-text">Command</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">参数、返回值特殊处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-key-%E5%89%8D%E7%BC%80"><span class="toc-number">4.3.</span> <span class="toc-text">设置 key 前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E5%91%BD%E4%BB%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">4.4.</span> <span class="toc-text">发送命令数据的生成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%8F%91%E9%80%81%E5%91%BD%E4%BB%A4"><span class="toc-number">5.</span> <span class="toc-text">Redis 发送命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DataHandler"><span class="toc-number">6.</span> <span class="toc-text">DataHandler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">8.</span> <span class="toc-text">参考资料</span></a></li></ol>
    </div>
  </div>
  <label class="mask" for="toggle-toc"></label>

<div id="post-content">
  <h1>ioredis源码阅读[0]</h1>
  <blockquote>
<p>最近因为工作需要，要去搞一个 Node.js 端的 <code>Redis Client</code> 组件出来，暂时选择通过 <code>ioredis</code> 来作为 fork 对象。<br>因为之前有遇到过 <code>Redis</code> 在使用 twemproxy 时会一直出现无法连接服务器的问题，详情见 issues：<a href="https://github.com/luin/ioredis/issues/573">https://github.com/luin/ioredis/issues/573</a><br>所以会修改源码修改这一问题，不过在修改完成之后跑单元测试发现，事情没有那么简单，并不只是 info -&gt; ping 这样，所以只好去熟悉源码，然后针对性地调整一下逻辑。</p>
</blockquote>
<span id="more"></span>

<h2 id="ioredis-项目结构"><a href="#ioredis-项目结构" class="headerlink" title="ioredis 项目结构"></a>ioredis 项目结构</h2><p>从项目中看，源码都在 <code>lib</code> 文件夹下，是一个纯粹的 TS 项目。<br><code>lib</code> 目录下的文件主要是一些通用能力的提供，比如 <code>command</code>、<code>pipeline</code>以及数据的传输等。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── DataHandler.ts                    <span class="comment"># 数据处理</span></span><br><span class="line">├── ScanStream.ts</span><br><span class="line">├── SubscriptionSet.ts</span><br><span class="line">├── autoPipelining.ts</span><br><span class="line">├── cluster                           <span class="comment"># Redis Cluster 模式的实现</span></span><br><span class="line">│   ├── ClusterOptions.ts</span><br><span class="line">│   ├── ClusterSubscriber.ts</span><br><span class="line">│   ├── ConnectionPool.ts</span><br><span class="line">│   ├── DelayQueue.ts</span><br><span class="line">│   ├── index.ts</span><br><span class="line">│   └── util.ts</span><br><span class="line">├── command.ts                        <span class="comment"># 命令的具体实现</span></span><br><span class="line">├── commander.ts                      <span class="comment"># command 的调度方</span></span><br><span class="line">├── connectors                        <span class="comment"># 网络连接相关</span></span><br><span class="line">│   ├── AbstractConnector.ts</span><br><span class="line">│   ├── SentinelConnector</span><br><span class="line">│   ├── StandaloneConnector.ts</span><br><span class="line">│   └── index.ts</span><br><span class="line">├── errors                            <span class="comment"># 异常信息相关</span></span><br><span class="line">│   ├── ClusterAllFailedError.ts</span><br><span class="line">│   ├── MaxRetriesPerRequestError.ts</span><br><span class="line">│   └── index.ts</span><br><span class="line">├── index.ts                          <span class="comment"># 入口文件</span></span><br><span class="line">├── pipeline.ts                       <span class="comment"># 管道逻辑</span></span><br><span class="line">├── promiseContainer.ts               <span class="comment"># Promise 的一个封装</span></span><br><span class="line">├── Redis                             <span class="comment"># `Redis 实例的实现`</span></span><br><span class="line">│   ├── RedisOptions.ts</span><br><span class="line">│   ├── event_handler.ts</span><br><span class="line">│   └── index.ts</span><br><span class="line">├── script.ts</span><br><span class="line">├── transaction.ts</span><br><span class="line">├── types.ts</span><br><span class="line">└── utils                             <span class="comment"># 一些工具函数的实现</span></span><br><span class="line">    ├── debug.ts</span><br><span class="line">    ├── index.ts</span><br><span class="line">    └── lodash.ts</span><br></pre></td></tr></table></figure>

<p>而下分的两个文件夹，<code>redis</code> 与 <code>cluster</code> 都是具体的 <code>redis</code> <code>client</code> 实现，<code>cluster</code> 是对应的 <code>cluster</code> 集群化实现。<br>所以在看 <code>README</code> 的时候我们会发现有两种实例可以使用，<a href="https://www.npmjs.com/package/ioredis">https://www.npmjs.com/package/ioredis</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Redis</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Redis</span>.<span class="property">Cluster</span></span><br></pre></td></tr></table></figure>

<p>我们先从最普通的 <code>Redis</code> 开始看，本篇笔记主要是针对 <code>Redis</code>，结合着 README 一步步捋逻辑。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="string">`Redis`</span> = <span class="built_in">require</span>(<span class="string">&quot;ioredis&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="string">`Redis`</span> = <span class="string">`new Redis`</span>();</span><br><span class="line"></span><br><span class="line">redis.<span class="title function_">set</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">redis.<span class="title function_">get</span>(<span class="string">&quot;foo&quot;</span>, <span class="keyword">function</span> (<span class="params">err, result</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最基础的使用顺序，首先实例化一个 <code>Redis</code> 对象，然后调用 <code>Redis</code> 对应的命令，如果对 <code>Redis</code> 命令不熟悉可以看一下这个网站：<a href="https://redis.io/commands#">https://redis.io/commands#</a></p>
<p>入口代码位于 redis&#x2F;index.ts，虽说 <code>ioredis</code> 用了 TS，但是构造函数的实现依然使用的是很古老的 ES5 方式，分别继承了 <code>EventEmitter</code> 和 <code>Commander</code> 两个类，第一个是 <code>events</code> 的，第二个则是 <code>ioredis</code> 自己提供的一个类，就在 <code>commander.ts</code> 文件中实现。</p>
<h2 id="Redis-实例化"><a href="#Redis-实例化" class="headerlink" title="Redis 实例化"></a>Redis 实例化</h2><p><code>Redis</code> 主要做的事情就是：</p>
<ul>
<li>建立并维护与 <code>Redis Server</code> 的网络连接</li>
<li>健康检查</li>
<li>维护队列在异常情况下保证请求不丢，可重试</li>
</ul>
<p>看回到 <code>Redis</code> 会看到针对 this.connector 的一个赋值，抛开自定义的 <code>Connector</code> 与 <code>Sentinels</code> 只看最后一项最普通的 <code>StandaloneConnector</code>，这里就是用来建立与 <code>Redis Server</code> 的连接的。<br>翻看 <code>lib/connectors/StandaloneConnector.ts</code> 的文件会发现，最终调用的是 <code>net.createConnection</code>，这个其实也能和咱们在上边提到的 <code>RESP</code> 所对应上，就是用的最基本的 <code>Redis</code> 通讯协议来完成操作的。</p>
<p>各项参数初始化完毕后，则会调用 <code>connect</code> 来与 <code>Redis Server</code> 建立真正的连接。</p>
<p><code>net</code> 模块的 <code>createConnection</code> 只能建立网络连接，并不能保证是我们预期的 <code>Redis</code> 服务。<br>通过 <code>connect</code> 拿到的 <code>stream</code> 对象其实就是 <code>socket client</code>：<a href="https://github.com/luin/ioredis/blob/master/lib/redis/index.ts#L321">https://github.com/luin/ioredis/blob/master/lib/redis/index.ts#L321</a><br>在 <code>connect</code> 方法中主要就是去建立与 <code>Redis Server</code> 的链接，在建立连接以后，我们会调用 <code>event_handler.connectHandler</code>方法。<br>这里主要做了两件事：</p>
<ol>
<li>去尝试 check <code>Redis Server</code> 的状态，也就是我们最开始提到的遇到的那个坑了，我们可以通过 <code>Redis.prototype._readyCheck</code> 方法看到具体的实现， <code>ioredis</code> 采用 <code>info</code> 命令作为探针，但是这个在 <code>twemproxy</code> 集群模式下就会产生一些问题，因为该模式会禁用一些命令，其中就包括 <code>info</code>，那么这就会导致 <code>Redis Client</code> 始终认为服务是不可用的。  </li>
<li>添加了针对 <code>socket client</code> 的 <code>data</code> 事件监听，这里是用于后续接受返回数据的，主要逻辑在 <code>DataHandler.ts</code>，后边会提到。</li>
</ol>
<blockquote>
<p>readyCheck 的逻辑存在于 redis&#x2F;index.ts 和 redis&#x2F;event_handler.ts 文件中  </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Redis</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_readyCheck</span> = <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">info</span>(<span class="keyword">function</span> (<span class="params">err, res</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">callback</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> res !== <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="literal">null</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">info</span>: &#123; [<span class="attr">key</span>: string]: any &#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> lines = res.<span class="title function_">split</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lines.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">const</span> [fieldName, ...fieldValueParts] = lines[i].<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">      <span class="keyword">const</span> fieldValue = fieldValueParts.<span class="title function_">join</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (fieldValue) &#123;</span><br><span class="line">        info[fieldName] = fieldValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!info.<span class="property">loading</span> || info.<span class="property">loading</span> === <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(<span class="literal">null</span>, info);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> loadingEtaMs = (info.<span class="property">loading_eta_seconds</span> || <span class="number">1</span>) * <span class="number">1000</span>;</span><br><span class="line">      <span class="keyword">const</span> retryTime =</span><br><span class="line">        _this.<span class="property">options</span>.<span class="property">maxLoadingRetryTime</span> &amp;&amp;</span><br><span class="line">        _this.<span class="property">options</span>.<span class="property">maxLoadingRetryTime</span> &lt; loadingEtaMs</span><br><span class="line">          ? _this.<span class="property">options</span>.<span class="property">maxLoadingRetryTime</span></span><br><span class="line">          : loadingEtaMs;</span><br><span class="line">      <span class="title function_">debug</span>(<span class="string">&quot;Redis server still loading, trying again in &quot;</span> + retryTime + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        _this.<span class="title function_">_readyCheck</span>(callback);</span><br><span class="line">      &#125;, retryTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在检测 <code>Redis</code> 可用以后则会触发 <code>callback</code>，该 <code>callback</code> 还会去检查 <code>offlineQueue</code> 是否有值，可以理解为是 <code>Redis</code> 可用之前调用命令的那些记录， <code>ioredis</code> 并不会直接报错告诉你说连接未建立，而是暂存在自己的一个队列中，等到可用后按照顺序发出去。<br><code>Redis</code> 在实例化的过程中主要也就是做了这些事情，接下来我们就要看 <code>Redis</code> 命令发出以后，具体执行的逻辑了。</p>
<h2 id="Commander"><a href="#Commander" class="headerlink" title="Commander"></a>Commander</h2><p>Commander 的作用就是实现了各种 <code>Redis Client</code> 的命令，通过 <a href="https://www.npmjs.com/package/redis-commands">https://www.npmjs.com/package/redis-commands</a> 遍历得到的。<br>同时会针对 <code>Client</code> 的 <code>Ready</code> 状态进行处理，在 <code>Ready</code> 之前会做一些暂存命令之类的操作。<br>比较像是一个抽象类，因为 <code>Redis</code> 和 <code>Redis Cluster</code> 都会继承并覆盖一些 API 来完成工作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">commands.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">commandName</span>) &#123;</span><br><span class="line">  <span class="title class_">Commander</span>.<span class="property"><span class="keyword">prototype</span></span>[commandName] = <span class="title function_">generateFunction</span>(commandName, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">  <span class="title class_">Commander</span>.<span class="property"><span class="keyword">prototype</span></span>[commandName + <span class="string">&quot;Buffer&quot;</span>] = <span class="title function_">generateFunction</span>(</span><br><span class="line">    commandName,</span><br><span class="line">    <span class="literal">null</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateFunction</span>(<span class="params">_encoding: string</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateFunction</span>(<span class="params">_commandName: string | <span class="keyword">void</span>, _encoding: string</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateFunction</span>(<span class="params">_commandName?: string, _encoding?: string</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> _encoding === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    _encoding = _commandName;</span><br><span class="line">    _commandName = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> commandName = _commandName || args.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">let</span> callback = args[args.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      args.<span class="title function_">pop</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      callback = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> options = &#123;</span><br><span class="line">      <span class="attr">errorStack</span>: <span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">showFriendlyErrorStack</span></span><br><span class="line">        ? <span class="keyword">new</span> <span class="title class_">Error</span>().<span class="property">stack</span></span><br><span class="line">        : <span class="literal">undefined</span>,</span><br><span class="line">      <span class="attr">keyPrefix</span>: <span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">keyPrefix</span>,</span><br><span class="line">      <span class="attr">replyEncoding</span>: _encoding,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">dropBufferSupport</span> &amp;&amp; !_encoding) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">asCallback</span>(</span><br><span class="line">        <span class="title class_">PromiseContainer</span>.<span class="title function_">get</span>().<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable constant_">DROP_BUFFER_SUPPORT_ERROR</span>)),</span><br><span class="line">        callback</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No auto pipeline, use regular command sending</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">shouldUseAutoPipelining</span>(<span class="variable language_">this</span>, commandName)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">sendCommand</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Command</span>(commandName, args, options, callback)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a new pipeline and make sure it&#x27;s scheduled</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">executeWithAutoPipelining</span>(<span class="variable language_">this</span>, commandName, args, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实现所有命令的同时还实现了一批 <code>Buffer</code> 后缀的 API，他们主要的区别我们可以通过 <code>generateFunction</code> 函数的实现来看到，被传入到了 <code>Command</code> 实例中。<br>而 <code>Command</code> 对象则是具体的命令实现，所以我们还需要先去看一下 Command。</p>
<h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><p><code>Command</code> 负责的事情，主要是参数的处理、返回值的处理，生成命令传输的实际值以及 <code>callback</code> 的触发。</p>
<h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>在 <code>Command</code> 的实例化过程中，除去一些属性的赋值，还调用了一个 <code>initPromise</code> 方法，在内部生成了一个 <code>Promise</code> 对象。<br>其中有两处比较重要的处理，一个是关于参数的转换，还有一个是返回值的处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private <span class="title function_">initPromise</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Promise</span> = <span class="title function_">getPromise</span>();</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">transformed</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">transformed</span> = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">const</span> transformer = <span class="title class_">Command</span>.<span class="property">_transformer</span>.<span class="property">argument</span>[<span class="variable language_">this</span>.<span class="property">name</span>];</span><br><span class="line">      <span class="keyword">if</span> (transformer) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">args</span> = <span class="title function_">transformer</span>(<span class="variable language_">this</span>.<span class="property">args</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">stringifyArguments</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resolve</span> = <span class="variable language_">this</span>.<span class="title function_">_convertValue</span>(resolve);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">errorStack</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reject</span> = <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="title function_">optimizeErrorStack</span>(err, <span class="variable language_">this</span>.<span class="property">errorStack</span>, __dirname));</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reject</span> = reject;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promise</span> = <span class="title function_">asCallback</span>(promise, <span class="variable language_">this</span>.<span class="property">callback</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数、返回值特殊处理"><a href="#参数、返回值特殊处理" class="headerlink" title="参数、返回值特殊处理"></a>参数、返回值特殊处理</h3><p>如果检索 <code>Command.ts</code> 文件，会发现 <code>Command._transformer.argument</code> 通过 <code>setArgumentTransformer</code> 方法进行设置。<br>然后再观察代码中有用到 <code>setArgumentTransformer</code> 的是少数几个 <code>hset</code> 命令，以及 <code>mset</code> 命令。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Command</span>.<span class="title function_">setArgumentTransformer</span>(<span class="string">&quot;hmset&quot;</span>, <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (args.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Map</span> !== <span class="string">&quot;undefined&quot;</span> &amp;&amp; args[<span class="number">1</span>] <span class="keyword">instanceof</span> <span class="title class_">Map</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [args[<span class="number">0</span>]].<span class="title function_">concat</span>(<span class="title function_">convertMapToArray</span>(args[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> args[<span class="number">1</span>] === <span class="string">&quot;object&quot;</span> &amp;&amp; args[<span class="number">1</span>] !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [args[<span class="number">0</span>]].<span class="title function_">concat</span>(<span class="title function_">convertObjectToArray</span>(args[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> args;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果大家使用过 <code>Redis</code> 的 <code>hash set</code> 操作，应该都会知道，操作多个键值的方式是通过追加参数完成的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; HMSET key field value [field value ...]</span><br></pre></td></tr></table></figure>

<p>这样在 JS 中使用也需要将一个数组传递进去，由用户自己维护数组的 key value，这样一个顺序的操作方式，必然是没有写 JS 习惯的 <code>Object</code> 传参要舒服的，所以 <code>ioredis</code> 提供一个参数转换的逻辑，用来将 <code>Object</code> 转换为一维数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">convertObjectToArray</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = keys.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(keys[i], obj[keys[i]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> convertMapToArray&lt;K, V&gt;(<span class="attr">map</span>: <span class="title class_">Map</span>&lt;K, V&gt;): <span class="title class_">Array</span>&lt;K | V&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line">  map.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value, key</span>) &#123;</span><br><span class="line">    result[pos] = key;</span><br><span class="line">    result[pos + <span class="number">1</span>] = value;</span><br><span class="line">    pos += <span class="number">2</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果仔细看 <code>Command._transformer</code> 会发现还有一个 <code>reply</code> 属性值，这里的逻辑主要在 <code>_convertValue</code> 中有所体现，大致就是在接收到返回值以后，会先调用我们传入的自定义函数用来处理返回值。<br>目前翻代码用到的唯一一处是 <code>hgetall</code> 的处理逻辑，<code>hmget</code> 与 <code>hgetall</code> 在 <code>Redis</code> 中都是返回一个数组的数据，而 <code>ioredis</code> 将数组按照 kv 的格式拼接为一个 <code>Object</code> 方便用户操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Command</span>.<span class="title function_">setReplyTransformer</span>(<span class="string">&quot;hgetall&quot;</span>, <span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(result)) &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; result.<span class="property">length</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">      obj[result[i]] = result[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="设置-key-前缀"><a href="#设置-key-前缀" class="headerlink" title="设置 key 前缀"></a>设置 <code>key</code> 前缀</h3><p>如果看 <code>Command</code> 实例化的过程中，还会发现有 <code>_iterateKeys</code> 这样的一个函数调用，该函数具有两个作用：</p>
<ol>
<li>提取参数中所有的 key</li>
<li>可选的将 key 添加一个前缀（prefix）</li>
</ol>
<p>函数内部使用了 <code>redis-commands</code> 的两个 API， <code>exists</code> 和 <code>getKeyIndexes</code>，用来获取参数数组中所有的 key 的下标。<br>因为这个函数做了两件事，所以在第一次看到构造函数的用法时，再看函数具体的实现，会对最后返回的 <code>this.keys</code> 很疑惑，但是当看到 <code>Command</code> 还提供了一个 <code>getKeys</code> API 就能够明白是怎样的逻辑了。  </p>
<p>如果设置了 <code>keyPrefix</code> ，则会触发 <code>_iterateKeys</code> 用来调整 key 名，并存储到 keys 中用于返回值。<br>当调用 <code>getKeys</code> 时，如果没有设置 <code>keyPrefix</code> ，则会用默认的空处理函数来执行同样的逻辑，就是获取所有的 key，然后返回出去；如果之前已经设置过 keyPrefix 那么就会直接返回 this.keys 不再重复执行逻辑。</p>
<p><img src="/images/redis-code-read/get-keys-flow.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数内逻辑</span></span><br><span class="line"><span class="keyword">if</span> (options.<span class="property">keyPrefix</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_iterateKeys</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> options.<span class="property">keyPrefix</span> + key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一处调用的位置</span></span><br><span class="line">public <span class="title function_">getKeys</span>(): <span class="title class_">Array</span>&lt;string | <span class="title class_">Buffer</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_iterateKeys</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="title function_">_iterateKeys</span>(</span><br><span class="line">  <span class="attr">transform</span>: <span class="title class_">Function</span> = <span class="function">(<span class="params">key</span>) =&gt;</span> key</span><br><span class="line">): <span class="title class_">Array</span>&lt;string | <span class="title class_">Buffer</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">keys</span> === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">keys</span> = [];</span><br><span class="line">    <span class="keyword">if</span> (commands.<span class="title function_">exists</span>(<span class="variable language_">this</span>.<span class="property">name</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> keyIndexes = commands.<span class="title function_">getKeyIndexes</span>(<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">args</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> index <span class="keyword">of</span> keyIndexes) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">args</span>[index] = <span class="title function_">transform</span>(<span class="variable language_">this</span>.<span class="property">args</span>[index]);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">keys</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">args</span>[index] <span class="keyword">as</span> string | <span class="title class_">Buffer</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">keys</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送命令数据的生成"><a href="#发送命令数据的生成" class="headerlink" title="发送命令数据的生成"></a>发送命令数据的生成</h3><p>大家使用 <code>Redis</code> 应该更多的是通过代码中的 <code>Client</code> 调用各种命令来做，偶尔会通过 redis-cli 直接命令行操作。<br>但其实 <code>Redis</code> 使用了一个叫做 <code>RESP</code> (REdis Serialization Protocol) 的协议来进行传输。<br>如果本机有 <code>Redis</code> 的话，我们在本地可以很简单的进行演示。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> -e <span class="string">&#x27;*1\r\n$4\r\nPING\r\n&#x27;</span> | nc 127.0.0.1 6379</span><br><span class="line">+PONG</span><br></pre></td></tr></table></figure>

<p>我们会得到一个 <code>+PONG</code> 字符串。这样的一个交互其实才是绝大多数 <code>Client</code> 与 <code>Redis Server</code> 交互时所使用的格式。  </p>
<blockquote>
<p>P.S. <code>RESP</code> 有提供人类可读的版本进行交互，但是性能相对要低一些。</p>
</blockquote>
<p>举例说明如果我们要执行一个 set 和一个 get 应该怎样去写这个命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开头代表注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SET hello world</span></span><br><span class="line"><span class="comment"># 参数个数</span></span><br><span class="line">*3</span><br><span class="line"><span class="comment"># 该行命令值的长度（set 命令）</span></span><br><span class="line"><span class="variable">$3</span></span><br><span class="line"><span class="comment"># 命令对应的值（set 命令）</span></span><br><span class="line">SET</span><br><span class="line"><span class="comment"># 该行命令值的长度（具体的 key: hello）</span></span><br><span class="line"><span class="variable">$5</span></span><br><span class="line"><span class="comment"># 命令对应的值（具体的 key: hello）</span></span><br><span class="line">hello</span><br><span class="line"><span class="comment"># 该行命令值的长度（value 的长度）</span></span><br><span class="line"><span class="variable">$5</span></span><br><span class="line"><span class="comment"># 命令对应的值（value 本体）</span></span><br><span class="line">world</span><br><span class="line"></span><br><span class="line"><span class="comment"># GET hello</span></span><br><span class="line"><span class="comment"># 参数个数</span></span><br><span class="line">*2</span><br><span class="line"><span class="comment"># 该行命令值的长度（get 命令）</span></span><br><span class="line"><span class="variable">$3</span></span><br><span class="line"><span class="comment"># 命令对应的值（get 命令）</span></span><br><span class="line">GET</span><br><span class="line"><span class="comment"># 该行命令值的长度（具体的 key: hello）</span></span><br><span class="line"><span class="variable">$5</span></span><br><span class="line"><span class="comment"># 命令对应的值（具体的 key: hello）</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p><code>set</code> 的返回值没什么意外，就是一个 <code>+OK</code>，而 <code>get</code> 的返回值则有两行，第一行 <code>$5</code> 表示返回值的长度，第二行才是真正的返回值 <code>world</code>。<br>所以如果去看 <code>Command</code> 的 toWritable 函数就是实现了这样的逻辑，因为比较长所以就不贴了：<a href="https://github.com/luin/ioredis/blob/master/lib/command.ts#L269">https://github.com/luin/ioredis/blob/master/lib/command.ts#L269</a>  </p>
<p><code>Command</code> 主要实现的就是这些逻辑，我们在 <code>Commander</code> 的视线中可以看到所有命令调用的末尾都会执行 <code>this.sendCommand</code>， 具体的调度就是在 <code>Redis</code>、<code>Redis Cluster</code> 等具体的实现中做的了。所以我们可以回到 <code>Redis</code> 去看下实现逻辑。  </p>
<h2 id="Redis-发送命令"><a href="#Redis-发送命令" class="headerlink" title="Redis 发送命令"></a>Redis 发送命令</h2><p><code>sendCommand</code> 的实现中，会进行 <code>Redis</code> 状态的检查，如果是 <code>wait</code> 或者 <code>end</code> 之类的，会进行对应的处理。<br>然后我们会去检查当前是否是一个可以发送命令的状态：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> writable =</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;ready&quot;</span> ||</span><br><span class="line">    (!stream &amp;&amp;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;connect&quot;</span> &amp;&amp;</span><br><span class="line">      commands.<span class="title function_">exists</span>(command.<span class="property">name</span>) &amp;&amp;</span><br><span class="line">      commands.<span class="title function_">hasFlag</span>(command.<span class="property">name</span>, <span class="string">&quot;loading&quot;</span>));</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">stream</span>) &#123;</span><br><span class="line">    writable = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">stream</span>.<span class="property">writable</span>) &#123;</span><br><span class="line">    writable = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">stream</span>.<span class="property">_writableState</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">stream</span>.<span class="property">_writableState</span>.<span class="property">ended</span>) &#123;</span><br><span class="line">    writable = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>代码还算比较清晰，这里也要提到一点，我们在处理 <code>info</code> 命令的问题是，使用 <code>ping</code> 命令来代替 <code>info</code>，最初就卡在了这里，后续 debug 发现， <code>ping</code> 命令并不具备 <code>loading</code> 这一 <code>flag</code> 特性，所以 <code>ping</code> 命令都被放到了 <code>offlineQueue</code> 中，针对这一情况，我们将 <code>ping</code> 添加一个额外的判断逻辑，确保 <code>write</code> 的值为真。  </p>
<p>接下来如果 <code>write</code> 为真，那么我们就会使用 <code>stream</code> 也就是前边建立的 socket 连接来发送我们真实的命令了，这时候就是调用的 <code>write</code> 并将 <code>Command#toWritable</code> 的返回值作为数据传进去，也就是之前提到的基于 <code>RESP</code> 格式的序列化。<br>同时会将一些信息放到 <code>commandQueue</code> 中，它和 <code>offlineQueue</code> 都是同一个类型的实例，后边会提到具体的作用。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">commandQueue</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">command</span>: command,  <span class="comment">// Command 实例</span></span><br><span class="line">  <span class="attr">stream</span>: stream,    <span class="comment">// socket client（其实并没有地方会用到它，不知道为什么要传过去）</span></span><br><span class="line">  <span class="attr">select</span>: <span class="variable language_">this</span>.<span class="property">condition</span>.<span class="property">select</span>, <span class="comment">// 这个也是没有被用到</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另一个开源的模块， denque: <a href="https://www.npmjs.com/package/denque">https://www.npmjs.com/package/denque</a></p>
</blockquote>
<p>如果 <code>write</code> 为假，那么命令就会被放到 <code>offlineQueue</code> 中。</p>
<p>结束逻辑后会把 <code>command.promise</code> 进行返回，我们在 <code>Command</code> 实例化过程中可以看到，其实是实例化了一个 <code>Promise</code> 对象，并把 <code>resolve</code> 与 <code>reject</code> 做了一次引用，后边在数据返回时会用到。<br>当我们命令已经发送完毕后，那么下一步就是等数据返回了，这里就要说到前边在介绍 <code>React</code> 实例化后 <code>connect</code> 所调用的 <code>DataHandler</code> 实例所做的事情了。  </p>
<h2 id="DataHandler"><a href="#DataHandler" class="headerlink" title="DataHandler"></a>DataHandler</h2><p><code>DataHandler</code> 是一个比较另类的类的写法，因为使用时就直接 <code>new</code> 了但并没有接收返回值。<br>在构造函数中，就做了两件事，一个是实例化了一个 <code>RedisParser</code> 对象，另一个就是监听了 <code>redis.stream.on(&#39;data&#39;)</code> 事件，也就是我们在实例化 <code>Redis</code> 时传递过来的 <code>socket client</code>，在 <code>data</code> 事件触发时调用 <code>RedisParser.execute</code> 来完成解析。<br><code>RedisParser</code> 是另一个开源模块了，有兴趣的小伙伴可以看这里：<a href="https://www.npmjs.com/package/redis-parser">https://www.npmjs.com/package/redis-parser</a><br>目前可以认为在调用 <code>execute</code> 方法后会调用实例化时传入的 <code>return Reply</code> 就可以了，这是一个解析后的 <code>response</code>，我们会拿到这个 <code>response</code> 之后会从 <code>commandQueue</code> 中依次取出之前传入的对象。<br>取出的方式是按照队列的方式来取的，通过 <code>shift</code>，每次取出队列中的第一个元素。<br>然后调用元素中 <code>command</code> 属性的 <code>resolve</code> 方法，也就是我们在调用各种 Redis 命令时传入的 <code>callback</code> 了。  </p>
<p>这里需要补充一些 <code>Redis</code> 相关的知识，我们从整个逻辑链路可以看到，大致是这样的：</p>
<ol>
<li>用户执行命令</li>
<li><code>Redis</code> 实例化 <code>Command</code> 并放入队列</li>
<li>接收到数据响应后解析数据，并获取队列中第一个元素，调用对应的 <code>callback</code></li>
</ol>
<p>同时间可能会有很多 <code>Redis</code> 请求被发出去，但是再接收到数据后并不需要去判断这次响应对应的是哪一个 <code>command</code>，因为 <code>Redis</code> 本身也是一个<a href="https://topic.alibabacloud.com/a/why-redis-is-single-threaded-and-why-is-redis-so-fast_1_47_30266528.html">单进程的工作模式</a>，命令的处理也会按照接收数据的先后顺序来处理，因为本身 <code>ioredis</code> 用的也是同一个 socket 连接，所以也不会存在说命令发送到远端的先后顺序会发生变化。<br>所以我们就可以很放心的通过最简单的方式， <code>push</code> + <code>shift</code> 来处理数据了。  </p>
<blockquote>
<p>这也是为什么一些大 key 的操作会导致整个 Redis 服务响应变慢了。（在不做分片之类的处理情况下）  </p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此为止，普通模式下的 <code>Redis Client</code> 整体逻辑我们已经梳理完了，从创建到发送命令到接收返回值。<br>后边会针对 <code>Redis Cluster</code> 再输出一篇笔记，一起来看一下在 <code>Cluster</code> 模式下又会有什么不一样的处理逻辑。  </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.npmjs.com/package/ioredis">ioredis</a></li>
<li><a href="https://redis.io/commands">redis commands</a></li>
<li><a href="https://nodejs.org/api/net.html">Node.js | net</a></li>
<li><a href="https://topic.alibabacloud.com/a/why-redis-is-single-threaded-and-why-is-redis-so-fast_1_47_30266528.html">Why Redis is single-threaded and why is Redis so fast!</a></li>
<li><a href="https://stackoverflow.com/questions/10489298/redis-is-single-threaded-then-how-does-it-do-concurrent-i-o">Redis is single-threaded, then how does it do concurrent I&#x2F;O?</a></li>
</ul>

</div>

<section class="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
<script>
  var disqus_shortname = 'jiashunming';
  
  var disqus_url = 'http://jiasm.github.io/2020/12/15/ioredis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-0/';
  
  var disqus_config = function () {
    this.page.url = location.href
    this.page.identifier = 'b416ad00-3ec0-11eb-950c-ad6351fa8ffb'
    this.page.title = document.querySelector('h1').innerText
  };
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.setAttribute('data-timestamp', +new Date());
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

<script>
  // I'm not sure your browser supports `es6`
  window.addEventListener('load', function () {
    [].concat(Array.from(document.querySelectorAll('code')), Array.from(document.querySelectorAll('pre'))).filter(function (item) {return item.className.indexOf('language') >= 0}).forEach(function (tag) { tag.classList.add('line-numbers') })
    Prism.highlightAll()

    let scrollY = window.scrollY
    let headersList = Array.from(document.querySelector('#post-content').querySelectorAll('h1,h2,h3,h4,h5,h6')).map(function (item) {
      let rect = item.getBoundingClientRect()
      let anchorTag = document.querySelector(`a.toc-link[href="#${item.id}"]`)

      if (!anchorTag) return
      return {
        top: scrollY + rect.top - rect.height,
        tag: item,
        anchorTag: anchorTag
      }
    }).filter(function (item) { return item })

    window.addEventListener('scroll', debounce(scrollHandler, 200))
    scrollHandler()

    function scrollHandler () {
      let scrollY = window.scrollY
      let minInfo = null

      for (let item of headersList) {
        if (!minInfo) {
          minInfo = item
          continue
        }

        if ((scrollY - item.top) >= 0 && (scrollY - minInfo.top) > (scrollY - item.top)) {
          minInfo = item
        }
      }

      if (minInfo) {
        headersList.forEach(function (item) {
          item.anchorTag && item.anchorTag.classList.remove('selected')
        })
        minInfo.anchorTag.classList.add('selected')
      }
    }

    function debounce (func, delay) {
      let debounceIdentify = 0
      return function () {
        debounceIdentify && clearTimeout(debounceIdentify)
        debounceIdentify = setTimeout(function () {
          debounceIdentify = 0
          func.apply(this, arguments)
        }, delay)
      }
    }
  })
</script>

        </main>
        <a href="#" class="goto-top">
          <i class="fa fa-chevron-up"></i>
        </a>
    </div>
    <footer class="footer">
  <div class="footer-content">
    <div class="footer-info" class="inner">
      <p class="copyright">&copy; 2025 ShunMing Jia<br></p>
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      theme by <a href="https://github.com/Jiasm/hexo-theme-sheet" target="_blank">Sheet</a>
    </div>
    <ul class="contact-info">
      
        <a class="contact-link" href="https://github.com/jiasm" target="_blank"><i class="fa fa-github"></i></a>
      
      
        <a class="contact-link" href="https://weibo.com/jarvis1996" target="_blank"><i class="fa fa-weibo"></i></a>
      
      
        <a class="contact-link" href="https://twitter.com/jiashm" target="_blank"><i class="fa fa-twitter"></i></a>
      
      
        <a class="contact-link" href="https://www.facebook.com/jiashunming" target="_blank"><i class="fa fa-facebook"></i></a>
      
      
        <a class="contact-link" href="mailto:jiashunming@outlook.com" target="_blank"><i class="fa fa-envelope"></i></a>
      
    </ul>
  </div>
</footer>

  <!-- 使用 DISQUS js 代码 -->
  <script id="dsq-count-scr" src="//jiashunming.disqus.com/count.js" async="async"></script>



      <script>
      function footerHandler () {
        if (!window.screen || !document.body) return
        var hasComments = document.querySelector('.comments')
        if ((window.screen.availHeight - (hasComments ? 350 : 0)) > document.body.clientHeight) {
          document.body.classList.add('fixed')
        } else {
          document.body.classList.remove('fixed')
        }
      }
      footerHandler()
      window.addEventListener('resize', footerHandler)
    </script>
  </body>
  <script>
    var pathname = new URL(location.href).pathname.replace(/\/$/, '')

    switch (pathname) {
      case '/about':
        document.querySelector('.menu-item-about').classList.add('active')
        break
      case '/contact':
        document.querySelector('.menu-item-contact').classList.add('active')
        break
      case '/links':
        document.querySelector('.menu-item-friends').classList.add('active')
        break
      default:
        document.querySelector('.menu-item-home').classList.add('active')
    }
  </script>
  
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f1f7cb8bfb6de7f6a6277fee35703d98";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    

</html>